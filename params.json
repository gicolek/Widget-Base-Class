{"name":"Widget-base-class","tagline":"Widget Base Class, which facilitates custom widget creation updating the values in the background.","body":"# Widget Base Class #\r\n\r\n## Word of introduction ##\r\n\r\nWidget Base Class is a PHP class which facilitates widget creation, by faster creationm sanitization, validation and updates of Widget fields. Such an approach lets one set up widgets much faster, without code repetitions and care for repeated data validation.\r\n\r\nThanks to that we can get rid of the update method completely and stop worrying about the form validation itself.\r\n\r\n## Usage ##\r\n\r\n### Instatitaion ###\r\n\r\nTo use the base class, simply include it within your theme / plugin files and then extend it with the child class, in a same way as you extend WP_Widget class.\r\n\r\nFor instance let's analyze the sample class which is a part of this repository\r\n\r\n`\r\nclass Sample_Widget_Base_Child extends Widget_Base {\r\n\tfunction __construct() {\r\n\t\t$this->text_fields = array( 'title' );\r\n\t\tparent::__construct(\r\n\t\t\t\t'sample_widget_base_child', // Base ID\r\n\t\t\t\t__( 'Supply Widget Base Child', 'textdomain' ), // Name\r\n\t\t\t\tarray( 'description' => __( 'Sample Widget Base Child.', 'textdomain' ), ) // Args\r\n\t\t);\r\n\t}\r\n` \r\n\r\nNote that, we're using the parent constructor here and we're passing the arguments of the new widget we want to have available.\r\n\r\n### Built in methods ###\r\n\r\nThe widget does all of the data validation on its own. However we have to define the fields we want to use, so that our base class would have an idea on what kind of fields we'd like to use.\r\n\r\nBy default the class handles the following fields\r\n\r\n* input\r\n* checkbox \r\n* select\r\n* textarea\r\n\r\nSay we want to define the title of our widget. Let's take a look at our constructor\r\n\r\n`\r\n\tfunction __construct() {\r\n\t\t$this->text_fields = array( 'title' );\r\n                /* some code here */\r\n\t\t);\r\n\t}\r\n` \r\n\r\nWe have defined an array of text_fields, which are then automatically validated and rendered by the base class.\r\nIn the same way we can define other fields. The class assumes their names go as follows:\r\n\r\n* text_fields\r\n* text_areas\r\n* checkboxes\r\n* select_fields\r\n\r\nNow we want to be sure that the text field is rendered on the Widget Dashboard place whenever we want it. Henceforth the parent `gti()` comes to help. We'll place it within our child class form method. \r\n\r\n`public function form($instance) {\r\n\t\t// generate the text input for the title of the widget. Note that the first parameter matches text_fields array entry\r\n\t\techo parent::gti(  'title', 'Title', $instance );\r\n\t}\r\n` \r\n\r\nThe method takes at least three arguments. The **first** one corresponds to the key within our text_fields array and serves as the inputs \"name\" and \"id\" attribute. The **second** one is the label of the input field. And the **third** one is the widget's instance. There are **two** more optional arguments \"note\" and a \"class\". The **first** one prints a nice side note below the field, which can serve as a helpful text for the end user. The **second** one assigns custom class to the input container.\r\n\r\nSimilary the functions for other fields follow the same naming pattern: **gt** - generate textarea,  **gtc** - generate checkbox, **gts** - generate the select field. To find out the complete list of arguments and their use cases analyze the code of the base class: https://github.com/gicolek/Widget-Base-Class/blob/master/widget-base.php","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}